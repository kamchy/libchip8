use std::slice::SliceIndex;
use crate::cpu::Addr;

const FONT: [[u8;5];16] = [
    [0xF0, 0x90, 0x90, 0x90, 0xF0],
    [0x20, 0x60, 0x20, 0x20, 0x70],
    [0xF0, 0x10, 0xF0, 0x80, 0xF0],
    [0xF0, 0x10, 0xF0, 0x10, 0xF0],
    [0x90, 0x90, 0xF0, 0x10, 0x10],
    [0xF0, 0x80, 0xF0, 0x10, 0xF0],
    [0xF0, 0x80, 0xF0, 0x90, 0xF0],
    [0xF0, 0x10, 0x20, 0x40, 0x40],
    [0xF0, 0x90, 0xF0, 0x90, 0xF0],
    [0xF0, 0x90, 0xF0, 0x10, 0xF0],
    [0xF0, 0x90, 0xF0, 0x90, 0x90],
    [0xE0, 0x90, 0xE0, 0x90, 0xE0],
    [0xF0, 0x80, 0x80, 0x80, 0xF0],
    [0xE0, 0x90, 0x90, 0x90, 0xE0],
    [0xF0, 0x80, 0xF0, 0x80, 0xF0],
    [0xF0, 0x80, 0xF0, 0x80, 0x80]];

pub struct Mem {
    cells: [u8;4096],
}

impl Mem {
    pub fn new() -> Self {
        Mem { cells: [0; 4096] }
    }
   
    pub fn store(&mut self, i: Addr, v: u8) {
        self.cells[i as usize] = v;
    }

    pub fn load(&mut self, i: Addr) -> u8 {
        self.cells[i as usize]
    }

    pub fn get<I>(&self, index: I) -> Option<&<I as SliceIndex<[u8]>>::Output> 
        where I: SliceIndex<[u8]>, {
        self.cells.get(index)
    }

    // todo private?
    pub fn load_font(&mut self, start: Addr) {
        for i in 0..16 {
            for b in 0..5 {
                let a: Addr = start + i*5 + b;
                self.store(a, FONT[i as usize][b as usize]);
            }
        }
    }
}
